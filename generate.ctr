import Library/Data/IO/Pen: 'pPen'.
import Library/Data/Set/HashSet: 'HashSet'.

File new: 'timestamps.ctr', exists ifTrue: {
  import timestamps: { data => 'timestamps'. }.
} ifFalse: {
  timestamps is Map new.
}.

var type is Object cnew: {
  on: 'new' do: {}.
  # on: 'cnew:' do: {}.

  allInstanceTypes => HashMap new.
  structures => Map new.
  alternative => False.
  allTypeDefs => HashMap new.
  on: 'complete' do: {
    alternative => False.
  }.
  on: 'allInstanceTypes' do: { ^my allInstanceTypes. }.
  on: 'allTypeDefs' do: { ^my allTypeDefs. }.
  on: 'respondTo:' do: {:self:typename
    typename = 'alternative' ifTrue: {
      alternative => True.
      ^me.
    }.
    var alternative is my alternative.
    ^Object cnew: {
      name => typename.
      alternative => alternative.
      type => self.
      on: 'applyAll:' do: {:defn
        var type is Nil.
        my alternative ifTrue: {
          errPen yellow write: 'type ${{my name}}$ has alternative definitions, ', resetColor.
          errPen red writeln: 'it will not be recorded (TODO)', resetColor.
        } ifFalse: {
          var structureId is my type getOrCreateStructure: defn.
          my type register: my name as: structureId.
          Reflect addGlobalVariable: my name.
          type is Type cnew: { structureId => structureId. underlayingJSType => Nil. returns => False. } named: my name.
          my type setType: my name to: type.
          Reflect set: my name to: type.
        }.
        my type complete.
        ^ type.
      }.
    }.
  }.
  on: 'setType:to:' do: {:name:type
    my allTypeDefs at: name, isNil ifTrue: {
      my allTypeDefs put: type at: name.
    }.
  }.
  on: 'register:as:' do: {:name:structureId
    my allInstanceTypes at: name, isNil ifFalse: {
      my alternative ifFalse: {
        errPen red writeln: 'structure $$structureId (${{miniPrintStructure: structureId}}$) already registered', resetColor.
      }.
      ^Nil.
    }.
    my allInstanceTypes put: structureId at: name.
  }.
  on: 'compileStructure:' do: {:str
    var tymap is HashMap new.
    str each_v: {:ntpair
      tymap contains: ntpair fname, ifTrue: {
        errPen red writeln: 'field ${{ntpair fname}}$ already exists in the structure as ${{tymap at: ntpair fname}}$, ignoring the new field', resetColor.
      } ifFalse: {
        tymap put: ntpair at: ntpair fname.
      }.
    }.
    ^tymap.
  }.
  on: 'getOrCreateStructure:' do: {:structure
    var compiled is compileStructure: structure.
    my structures put: compiled at: (var id is my structures count).
    ^id.
  }.
  on: 'getStructure:' do: {:id
    ^my structures at: id.
  }.
  on: 'miniPrintStructure:' do: {:id
    var compiled is my structures at: id.
    compiled isNil ifTrue: {
      ^'{}'.
    }.
    ^miniPrintStructureEx: compiled ftype.
  }.
  on: 'miniPrintStructureEx:' do: {:compiled
    var s is '{'.
    compiled isA: Type, ifTrue: {
      s +=: (compiled _underlayingJSType or: compiled) + ', '.
    } ifFalse: {
      compiled each: {:k:v
        s +=: '${{k}}$:${{v}}$, '.
      }.
    }.
    ^s from: 0 length: s length - 2, + '}'.
  }.
}.

var Type is Object cnew: {
  on: 'cnew:named:' do: {:blk:name
    ^me cnew: blk, name: name.
  }.
  genAccessors: ['structureId', 'return', 'returns', 'native?', 'itype!'].
  itype!: Nil.
  on: 'name:' do: {:name my name is name. }.
  on: 'toString' do: { ^my name. }.
  on: 'applyAll:' do: {
    ^ArrayType getOrCreate: me.
  }.
  on: '_underlayingJSType' do: { ^my underlayingJSType or: my name. }.
  on: '->' do: {:ret
    returns => True.
    return => ret.
  }.
  on: 'respondTo:' do: {:self:name
    ^Object cnew: {
      ftype => self.
      fname => name.
      underlayingJSType => Nil.
      default => Nil.
      unique? => False.
      pure? => False.
      returns => False.
      return => Nil.
      genAccessors: ['fname', 'ftype', 'unique?', 'pure?'].
      on: 'unique' do: { my unique? is True. }.
      on: 'pure' do: { my pure? is True. }. # only applies to models
      on: 'toString' do: {
        ^'<%s %s>' % [my ftype, my fname].
      }.
      on: 'default:' do: {:def default => def. }.
      on: 'default?' do: { ^my default isNil not. }.
      on: 'default!' do: { ^my default. }.
      on: 'jsdefault' do: { ^my default or: 'null'. }.
      on: 'default' do: { ^my default or: my ftype _underlayingJSType, or: my ftype. }.
      on: 'type' do: { ^'NameTypePair'. }.
      on: 'applyAll:' do: {:x default: x head. }.
      on: '=' do: {:other
        other type = 'NameTypePair' ifTrue: {
          ^(my fname = other fname) & (my ftype = other ftype).
        } ifFalse: {
          ^False.
        }.
      }.
    }.
  }.
}.

var ArrayType is Type cnew: {
  typemap => Map new.
  returns => False.
  on: 'getOrCreate:' do: {:inner
    var instance is my typemap at: inner.
    instance isNil ifTrue: {
      instance is me create: inner.
      my typemap put: instance at: inner.
      ^instance.
    } ifFalse: {
      ^instance.
    }.
  }.
  on: 'create:' do: {:self:inner
    ^me cnew: {
      native?: True.
      etype => inner.
    }.
  }.
  on: '_underlayingJSType' do: { ^'ArrayType(' + (my etype _underlayingJSType or: my etype) + ')'. }.
  on: 'toString' do: {
    ^'%s[]' % [my etype].
  }.
}.

var int is Type cnew: {
  returns => False.
  underlayingJSType => 'Number'.
  native?: True.
} named: 'int'.

var string is Type cnew: {
  returns => False.
  underlayingJSType => 'String'.
  native?: True.
} named: 'string'.

var double is Type cnew: {
  returns => False.
  underlayingJSType => 'Number'.
  native?: True.
} named: 'double'.

var boolean is Type cnew: {
  returns => False.
  underlayingJSType => 'Boolean'.
  native?: True.
} named: 'boolean'.

var enum is Object cnew: {
  choicemap => Map new.
  on: 'choicemap' do: {^my choicemap.}.
  on: 'applyAll:' do: {:self:choices
    var ty is my choicemap at: choices.
    ty isNil ifTrue: {
      var name is 'enum' + my choicemap count.
      ty is Type cnew: {
        returns => False.
        choices => choices.
        underlayingJSType => name upper1st.

        native?: False.
        itype!: self.

        on: 'choices!' do: { ^my choices. }.
      } named: name.
      my choicemap put: ty at: choices.
    }.
    ^ty.
  }.
}.

type register: 'int' as: int.
type register: 'string' as: string.
type register: 'double' as: double.
type register: 'boolean' as: boolean.

###################################  Request ###################################
var Specification is Object cnew: {
  mode => 'post'.
  on: 'type' do: { ^'Specification'. }.
  on: 'toString' do: { ^'<Spec: ${{type miniPrintStructureEx: my fields}}$>'. }.
  on: 'mode:' do: {:md mode => md. }.
  on: 'mode' do: { ^my mode. }.
  on: 'fields' do: { ^my fields. }.
}.
var RequestSpecification is Specification cnew: {
  decoder => 'JSON.parse'.
  on: 'decoder:' do: {:dec my decoder is dec. }.
  on: 'decoder!' do: { ^my decoder. }.
  on: 'decoder' do: {:self
    ^{:decoder
      extra-imports add: (decoder split: '.' max: 1, head).
      const self decoder: decoder.
      ^const self.
    }.
  }.
}.
var ResponseSpecification is Specification cnew: {
  encoder => 'JSON.stringify'.
  on: 'encoder:' do: {:enc my encoder is enc. }.
  on: 'encoder!' do: { ^my encoder. }.
  on: 'encoder' do: {:self
    ^{:encoder
      extra-imports add: (encoder split: '.' max: 1, head).
      const self encoder: encoder.
      ^const self.
    }.
  }.
}.
var ActionSpecification is Specification cnew: {
  on: 'toString' do: { ^'<ActionSpec: %L>' % [my comments fmap: \:x '"%s"' % [x]]. }.
  on: 'each:' do: {:blk
    my comments each: blk.
  }.
}.
var BeforeSpecification is Specification cnew: {
  on: 'toString' do: { ^'<BeforeSpecification with %d subscribers>' % [my functions count]. }.
  on: 'each:' do: {:blk
    my functions each: blk.
  }.
}.
var Request is Object cnew: {
  on: 'applyAll:' do: {:args
    ^RequestSpecification cnew: {
      decoder => 'JSON.parse'.
      fields => (type compileStructure: args).
    }.
  }.
  on: 'respondTo:' do: {:name
    var ty is Reflect getObject: name.
    ^RequestSpecification cnew: {
      fields => ty. #type getStructure: ty structureId, or: (model getStructure: ty structureId).
    }.
  }.
}.
var Response is Object cnew: {
  on: 'applyAll:' do: {:args
    ^ResponseSpecification cnew: {
      fields => (type compileStructure: args).
    }.
  }.

  on: 'respondTo:' do: {:name
    var ty is Reflect getObject: name.
    ^ResponseSpecification cnew: {
      fields => ty. #type getStructure: ty structureId, or: (model getStructure: ty structureId).
    }.
  }.
}.
var Action is Object cnew: {
  on: 'applyAll:' do: {:args
    ^ActionSpecification cnew: {
      comments => args.
    }.
  }.
  on: 'process:' do: {:arg ^me applyAll: [arg]. }.
}.

var Before is Object cnew: {
  on: 'applyAll:' do: {:args
    ^BeforeSpecification cnew: {
      functions => args.
    }.
  }.
}.
################################### endpoint ###################################
#################################### action ####################################
var endpoints is Map new.
var actions is Map new.
var extra-imports is HashSet new.

var EndpointSpec is Object cnew: {
  on: 'create:withRequest:andResponse:andBefore:' do: {:name:request:response:before
    ^cnew: {
      mode => api endpointType.
      request => request.
      response => response.
      before => before.
      name => name.
    }.
  }.
  genAccessors: ['request', 'response', 'before', 'mode'].
  on: 'each:' do: {:blk
    my request isNil ifFalse: {
      blk applyTo: 'Request' and: my request.
    }.
    my response isNil ifFalse: {
      blk applyTo: 'Response' and: my response.
    }.
    my before isNil ifFalse: {
      blk applyTo: 'Before' and: my before.
    }.
  }.
  on: 'toString' do: {
    ^'<%s Endpoint "%s" req: %s, resp: %s, bef: %s>' % [my mode, my name, my request, my response, my before].
  }.
}.

var ActionSpec is Object cnew: {
  on: 'create:withRequest:andResponse:andBefore:andAction:' do: {:name:request:response:before:action
    ^cnew: {
      mode => 'post'.
      request => request.
      response => response.
      before => before.
      action => action.
      name => name.
    }.
  }.
  genAccessors: ['request', 'response', 'action', 'before', 'mode'].
  on: 'each:' do: {:blk
    my request isNil ifFalse: {
      blk applyTo: 'Request' and: my request.
    }.
    my response isNil ifFalse: {
      blk applyTo: 'Response' and: my response.
    }.
    my action isNil ifFalse: {
      blk applyTo: 'Action' and: my action.
    }.
    my before isNil ifFalse: {
      blk applyTo: 'Before' and: my before.
    }.
  }.
  on: 'toString' do: {
    ^'<%s Action "%s" req: %s, resp: %s, bef: %s, act: %s>' % [my mode, my name, my request, my response, my before, my action].
  }.
}.

var endpoint is Object cnew: {
  on: 'respondTo:' do: {:name
    endpoints contains: name, ifTrue: {
      outPen red writeln: 'an endpoint named \'${{name}}$\' has already been registered'.
      ^Nil.
    }.
    ^Object cnew: {
      name => name.
      endpoints => endpoints.
      on: 'applyAll:' do: {:args
        var req is Nil.
        var res is Nil.
        var bef is Nil.
        args each_v: {:arg
          arg isA: RequestSpecification, ifTrue: {
            req is arg.
            ^Nil.
          }.
          arg isA: ResponseSpecification, ifTrue: {
            res is arg.
            ^Nil.
          }.
          arg isA: BeforeSpecification, ifTrue: {
            bef is arg.
            ^Nil.
          }.
          errPen red writeln: 'endpoint specification can only be a Request, a Response, or a Before', resetColor.
        }.
        my endpoints put: (
          EndpointSpec
            create: my name
            withRequest: req
            andResponse: res
            andBefore: bef)
          at: my name.
      }.
    }.
  }.
}.
var action is Object cnew: {
  on: 'respondTo:' do: {:name
    actions contains: name, ifTrue: {
      errPen red writeln: 'an action named \'${{name}}$\' has already been registered'.
      ^Nil.
    }.
    ^Object cnew: {
      name => name.
      actions => actions.
      pure => False.
      on: 'pure' do: { my pure is True. }.
      on: 'applyAll:' do: {:args
        var req is Nil.
        var res is Nil.
        var act is Nil.
        var bef is Nil.
        args each_v: {:arg
          arg isA: RequestSpecification, ifTrue: {
            req is arg.
            ^Nil.
          }.
          arg isA: ResponseSpecification, ifTrue: {
            res is arg.
            ^Nil.
          }.
          arg isA: ActionSpecification, ifTrue: {
            act is arg.
            ^Nil.
          }.
          arg isA: BeforeSpecification, ifTrue: {
            bef is arg.
            ^Nil.
          }.
          errPen red writeln: 'action specification can only be a Request, a Response, a Before or an Action', resetColor.
        }.
        act isNil ifTrue: {
          errPen red writeln: 'action rule ${{my name}}$ contains no `Action` field', resetColor.
        }.
        var spec is ActionSpec
            create: my name
            withRequest: req
            andResponse: res
            andBefore: bef
            andAction: act,
            mode: (my pure either: 'get' or: 'post').
        my actions put: spec at: my name.
      }.
    }.
  }.
}.

# var functions is Map new.

var function is type cnew: {
  allInstanceTypes => HashMap new.
  allTypeDefs => HashMap new.
  structures => Map new.
  alternative => False.
}.

#################################### model #####################################
var models is Map new.

var ModelSpec is Object cnew: {
  # TODO
}.

var model is type cnew: {
  allInstanceTypes => HashMap new.
  allTypeDefs => HashMap new.
  structures => Map new.
  alternative => False.
}.

var reference is Type cnew: {
  returns => False.
  on: 'applyAll:' do: {:ex
    ^ReferenceType getOrCreate: ex head.
  }.
} named: 'reference'.

var ReferenceType is Type cnew: {
  returns => False.
  typemap => Map new.
  on: 'getOrCreate:' do: {:inner
    var instance is my typemap at: inner.
    instance isNil ifTrue: {
      instance is me create: inner.
      my typemap put: instance at: inner.
      ^instance.
    } ifFalse: {
      ^instance.
    }.
  }.
  on: 'create:' do: {:inner
    ^me cnew: {
      etype => inner.
    }.
  }.
  on: '_underlayingJSType' do: { ^'String'. }.
  on: 'toString' do: {
    ^'reference[%s]' % [my etype].
  }.
}.

model register: 'int' as: int.
model register: 'string' as: string.
model register: 'double' as: double.
model register: 'boolean' as: boolean.
model register: 'reference' as: reference.

################################ generate api ##################################

var api is Object cnew: {
  ignoreRequests => False.
  ignReqId => 0.
  loglevel => \none. # debug, info, warn, none
  endpointType => 'get'.
  outfile => 'out.js'.
  on: 'outputFile:' do: {:n
    my ignoreRequests ifTrue: { ^me. }.
    outfile => n.
  }.
  on: 'openOutputFile' do: {
    my ignoreRequests ifTrue: { ^File special: 'stderr'. }.
    ^File new: my outfile, open: 'w+'.
  }.
  on: 'ignoreRequests' do: {
    my ignoreRequests ifTrue: {
      ^Nil.
    }.
    ignoreRequests => True.
    my ignReqId +=: 1.
    ^my ignReqId.
  }.
  on: 'enableRequests:' do: {:ig
    my ignReqId = ig ifTrue: {
      ignoreRequests => False.
    }.
  }.
  on: 'postEndpoints' do: {
    my ignoreRequests ifTrue: { ^Nil. }.
    endpointType => 'post'.
  }.
  on: 'getEndpoints' do: {
    my ignoreRequests ifTrue: { ^Nil. }.
    endpointType => 'get'.
  }.
  on: 'endpointType' do: {
    ^my endpointType.
  }.
  on: 'log:' do: {:level
    my ignoreRequests ifTrue: { ^Nil. }.
    loglevel => level.
  }.
  on: 'log' do: { ^my loglevel. }.
  on: 'prettyPrintSpec:' do: {:spec
    var s is ''.
    spec each: {:ty:spc
      s +=: '$$ty [\n\t\t\t\t$$spc'.
      s +=: '\n\t\t\t],\n\t\t\t'.
    }.
    ^s.
  }.
  on: 'toString' do: {
    ^'Actions:\n' + const actions + '\n' + ('-' * 80) + '\n' + 'Endpoints:\n' + const endpoints + '\n'.
  }.
  on: 'describe' do: {
    my ignoreRequests ifTrue: { ^Nil. }.
    outPen writeln: 'These types are defined:'.
    type allInstanceTypes each: {:k:v
      outPen writeln: '\t$$k - $$v ${{type miniPrintStructure: v}}$'.
    }.
    model allInstanceTypes each: {:k:v
      outPen writeln: '\t$$k - $$v ${{model miniPrintStructure: v}}$'.
    }.
    outPen write: 'The API has ${{actions count}}$ Actions'.
    outPen writeln: ', and ${{endpoints count}}$ Endpoints:'.
    actions each: {:name:spec
      outPen writeln: '\taction $$name ['.
      outPen writeln: '\t\t${{prettyPrintSpec: spec}}$'.
      outPen writeln: '\t]'.
    }.
    endpoints each: {:name:spec
      outPen writeln: '\tendpoint $$name ['.
      outPen writeln: '\t\t${{prettyPrintSpec: spec}}$'.
      outPen writeln: '\t]'.
    }.
  }.
  on: 'writeJsonFor:' do: {:reqps
    my ignoreRequests ifTrue: { ^Nil. }.
    reqps each_v: {:req
      var point is endpoints @ req or: actions @ req.
      Pen writeln: '$$req = {'.
      point request isNil ifFalse: {
        point request fields each: {:k:v
          Pen writeln: '\t"${{k}}$": ${{v default! or: 'null'}}$,'.
        }.
      }.
      Pen writeln: '}'.
    }.
  }.
  on: 'listIncomplete' do: {
    my ignoreRequests ifTrue: { ^Nil. }.
    var s is Array new.
    const timestamps each: {:path:time
      time >=: (File new: path, stat @ 'st_mtime'), ifTrue: {
        s push: path.
      }.
    }.
    ^s.
  }.
  on: 'generate' do: {
    my ignoreRequests ifTrue: { ^Nil. }.
    # generate js...?
    # express + toplevel boilerplate
    outPen writeln: 'var express = require("express");\nvar app = express();\n'.
    outPen writeln: 'db = null;\ndbsession = null;\nconst config = require("./config.js");\nconst MongoClient = require("mongodb").MongoClient;\n'.
    extra-imports count !=: 0, ifTrue: {
      extra-imports each_v: {:imp
        outPen writeln: 'const $$imp = require("${{imp}}$");'.
      }.
    }.

    endpoints each: {:k
      outPen writeln: 'const process_${{k ~ 's/\\W/_/g'}}$ = require("./endpoints/${{k ~ 's/\\W/_/g'}}$.js");'.
    }.
    actions each: {:k:spec
      outPen writeln: 'const process_${{k ~ 's/\\W/_/g'}}$ = require("./endpoints/${{k ~ 's/\\W/_/g'}}$.js");'.
      spec action each: {:i
        outPen writeln: 'const action_${{k ~ 's/\\W/_/g'}}$_${{i}}$ = require("./actions/${{k ~ 's/\\W/_/g'}}$-action${{i}}$.js");'.
      }.
    }.
    outPen brk.
    # first, define the types
    var f is File new: 'types.js'.
    f exists ifTrue: {
      errPen magenta write: 'types file exists at $$f', red write: ' overwriting it.', resetColor brk.
    }.
    f open: 'w+'.
    var typePen is pPen for: f.
    typePen writeln: 'module.exports = {};'.
    var typenames is Array < 'ArrayType'.
    type allInstanceTypes each: {:k:v
      v isA: Number, ifTrue: {
        typenames push: k.
        typePen writeln: 'let $$k = {'.
        var struct is type getStructure: v.
        var sprops is Array < 'call' ; 'staticProperties' ; 'forEach'.
        struct each: {:k:v
          v pure? ifTrue: {
            sprops push: k.
          }.
          typePen writeln: '\t\'${{k}}$\': arg => ${{v ftype _underlayingJSType or: v ftype}}$.call(null, arg),'.
        }.
        typePen write: '\tstaticProperties: [%:L],\n' % [', ', sprops fmap: \:x '"%s"' % [x]].
        typePen writeln: '\tcall(_, value) {'.
        typePen writeln: '\t\tlet obj = {};'.
        typePen writeln: '\t\tfor (property in ${{k}}$)'.
        typePen writeln: '\t\t\tif ((!${{k}}$.staticProperties.includes(property)) && ${{k}}$.hasOwnProperty(property))'.
        typePen writeln: '\t\t\t\tobj[property] = ${{k}}$[property](value[property]);'.
        typePen writeln: '\t\treturn obj;\n\t},'.
        typePen writeln: '\tforEach(self, callback) {'.
        typePen writeln: '\t\tfor (property in ${{k}}$)'.
        typePen writeln: '\t\t\tif ((!${{k}}$.staticProperties.includes(property)) && self.hasOwnProperty(property))'.
        typePen writeln: '\t\t\t\tcallback(property, self[property], self);'.
        typePen writeln: '\t}'.
        typePen writeln: '};'.
        typePen writeln: 'module.exports["${{k}}$"] = $$k'.
        typePen brk.
      }.
    }.
    enum choicemap each: {:_:type
      var typename is type toString upper1st.
      typenames push: typename.
      typePen writeln: 'let $$typename = {'.
      typePen writeln: '\tchoices: [%:L],' % [', ', type choices! fmap: \:x '"%s"' % [x escapeDoubleQuotes]].
      typePen writeln: '\tcall(_, value) {'.
      typePen writeln: '\t\tif (${{typename}}$.choices.includes(value))'.
      typePen writeln: '\t\t\treturn value;'.
      typePen writeln: '\t\telse'.
      typePen writeln: '\t\t\treturn undefined;'.
      typePen writeln: '\t}'.
      typePen writeln: '};'.
      typePen writeln: 'module.exports["${{typename}}$"] = $$typename'.
    }.
    typePen writeln: 'function ArrayType(inner) {'.
    typePen writeln: '\treturn {\n\t\tcall(_, value) {'.
    typePen writeln: '\t\t\treturn Array.prototype.slice.call(value).map(x => inner.call(null, x));'.
    typePen writeln: '\t\t}\n\t};\n};'.
    typePen writeln: 'module.exports["ArrayType"] = ArrayType;'.
    # then, define the model types
    var modelnames is Array new.
    var f is File new: 'models.js'.
    f exists ifTrue: {
      errPen magenta write: 'models file exists at $$f', red write: ' overwriting it.', resetColor brk.
    }.
    f open: 'w+'.
    var modelPen is pPen for: f.
    modelPen writeln: 'const {%:L} = require("./types.js");' % [', ', typenames].
    modelPen writeln: 'const { ObjectId } = require("mongodb");'.
    modelPen writeln: 'module.exports = {};'.
    # var typenames is Array < 'ArrayType'.
    model allInstanceTypes each: {:k:v
      v isA: Number, ifTrue: {
        modelnames push: k.
        modelPen writeln: 'let $$k = {'.
        var struct is model getStructure: v.
        var sprops is Array < 'call' ; 'db' ; 'findById' ; 'staticProperties' ; 'forEach'.
        struct each: {:k:v
          v pure? ifTrue: {
            sprops push: k.
            v default? ifFalse: {
              errPen yellow write: 'pure property $$k of model ${{modelnames last}}$ does not have a value set', resetColor brk.
            }.
            modelPen writeln: '\t\'${{k}}$\': ${{v default! or: 'null'}}$,'.
          } ifFalse: {
            modelPen writeln: '\t\'${{k}}$\': arg => ${{v ftype _underlayingJSType or: v ftype}}$.call(null, arg),'.
          }.
        }.
        modelPen write: '\tstaticProperties: [%:L],\n' % [', ', sprops fmap: \:x '"%s"' % [x]].
        modelPen writeln: '\tcall(_, value) {'.
        modelPen writeln: '\t\tlet obj = {};'.
        modelPen writeln: '\t\tfor (property in ${{k}}$)'.
        modelPen writeln: '\t\t\tif ((!${{k}}$.staticProperties.includes(property)) && ${{k}}$.hasOwnProperty(property))'.
        modelPen writeln: '\t\t\t\tobj[property] = ${{k}}$[property](value[property]);'.
        modelPen writeln: '\t\treturn obj;\n\t},'.
        modelPen writeln: '\tforEach(self, callback) {'.
        modelPen writeln: '\t\tfor (property in ${{k}}$)'.
        modelPen writeln: '\t\t\tif ((!${{k}}$.staticProperties.includes(property)) && self.hasOwnProperty(property))'.
        modelPen writeln: '\t\t\t\tcallback(property, self[property], self);'.
        modelPen writeln: '\t},'.
        # database access methods
        modelPen writeln: '\tdb() { return db.collection("${{k}}$") },'.
        modelPen writeln: '\tasync findById(id) {\n\t\treturn await db.collection("${{k}}$").findOne({\n\t\t\t$and:\n\t\t\t\t[\n\t\t\t\t\t{_id: new ObjectId(id)},\n\t\t\t\t\t...(Array.prototype.slice.call(arguments, 1))\n\t\t\t\t]\n\t\t});\n\t},'.
        modelPen writeln: '};'.
        modelPen writeln: 'module.exports["${{k}}$"] = $$k'.
        modelPen brk.
      }.
    }.
    # generate utility functions
    var functionNames is Array new.
    var f is File new: 'utilities'.
    f exists ifFalse: {
      f mkdir.
    }.

    function allInstanceTypes each: {:k:v
      v isA: Number, ifTrue: {
        functionNames push: k.
        var f is File new: 'utilities/${{k}}$.js'.
        f exists ifTrue: {
          errPen magenta writeln: 'function definition for $$k exists at ${{f}}$, not touching it'.
        } ifFalse: {
          f open: 'w+'.
          var funcPen is pPen for: f.
          funcPen writeln: 'const {%:L} = require("../types.js");' % [', ', typenames].
          funcPen writeln: 'const {%:L} = require("../models.js");' % [', ', modelnames].
          funcPen brk.
          funcPen write: 'module.exports = async function ${{k}}$('.
          var struct is function getStructure: v.
          var s is Array new < 'args' ; 'failure'.
          var type is function allTypeDefs at: k.
          type returns ifTrue: {
            s push: type return fname.
          }.
          funcPen writeln: '%:L) {' % [', ', s].
          struct each: {:k:v
            funcPen writeln: '\tlet $$k = args.${{k}}$;'.
          }.
          funcPen writeln: '\t// TODO: do something you\'re supposed to do'.
          type returns ifTrue: {
            funcPen writeln: '\t${{type return fname}}$.value = null; // return ${{type return ftype}}$'.
          }.
          funcPen writeln: '\treturn true;'.
          funcPen writeln: '}'.
          f close.
        }.
      }.
    }.
    # then import all
    outPen writeln: 'const {%:L} = require("./types.js");' % [', ', typenames].
    outPen writeln: 'const {%:L} = require("./models.js");' % [', ', modelnames].
    functionNames each_v: {:funcname
      outPen writeln: 'const $$funcname = require("./utilities/${{funcname}}$.js");'.
    }.
    outPen brk.
    outPen writeln: 'function getOrFail(type, obj, prop, _default) {\n\t' +
                 'let oprop = obj[prop];\n\t' +
                 'if ((typeof(oprop) === "undefined" || oprop === null) && !_default) {\n\t' +
                  (api log = \debug either:
                    '\tconsole.log("[DEBUG] nonexistent getOrFail for " + prop + " from " + JSON.stringify(obj));\n\t'
                  or: '') +
                 '\tthrow new Error(`missing argument ${prop}`);\n\t}\n\t' +
                 'if (typeof(oprop) === "undefined" || oprop === null)\n\t\t' +
                 'return _default;\n\t' +
                 'oprop = type.call(null, oprop);\n\t' +
                 'if ((typeof(oprop) === "undefined" || oprop === null) && !_default) {\n\t' +
                  (api log = \debug either:
                    '\tconsole.log("[DEBUG] nonexistent getOrFail for " + prop + " from " + JSON.stringify(obj));\n\t'
                  or: '') +
                 '\tthrow new Error(`wrong type for argument ${prop}`);\n\t}\n\t' +
                 'return (typeof(oprop) === "undefined" || oprop === null) ? _default : oprop;\n}' .
    # then, define the fancy routes for endpoints
    { File new: 'endpoints', mkdir. } catch: {}, run.
    endpoints each: {:route:spec
      var typedoc_in is '/**\n * res_input\n'.
      var typedoc_out is '/**\n * res_output\n'.
      var out_constructors is ''.

      (spec request isNil either: True or: { ^spec request fields isNil. }) ifTrue: {
        typedoc_in +=: ' */\n'.
      } ifFalse: {
        var fields is spec request fields.
        fields isA: Type, ifTrue: {
          typedoc_in +=: ' * @param ${{k}}$: ${{fields _underlayingJSType or: fields}}$\n'.
        } ifFalse: {
          spec request fields each: {:k:v
            typedoc_in +=: ' * @param ${{k}}$: ${{v ftype _underlayingJSType or: v ftype}}$\n'.
          }.
        }.
        typedoc_in +=: ' */\n'.
      }.

      (spec response isNil either: True or: { ^spec response fields isNil. }) ifTrue: {
        typedoc_out +=: ' */\n'.
      } ifFalse: {
        var fields is spec response fields.

        fields isA: Type, ifTrue: {
            typedoc_out +=: ' * = ${{fields _underlayingJSType or: fields}}$\n'.
            out_constructors +=: 'constructReturn = x => (${{fields _underlayingJSType or: fields}}$).call(null, x);\n'.
        } ifFalse: {
          fields each: {:k:v
            typedoc_out +=: ' * @param ${{k}}$: ${{v ftype _underlayingJSType or: v ftype}}$\n'.
            out_constructors +=: 'construct${{k upper1st}}$ = x => (${{v ftype _underlayingJSType or: v ftype}}$).call(null, x);\n'.
          }.
        }.
        typedoc_out +=: ' */\n'.
      }.

      var f is File new: 'endpoints/${{route ~ 's/\\W/_/g'}}$.js'.
      var exists is False.
      f exists ifTrue: {
        timestamps @ f path < (f stat @ 'st_mtime') ifTrue: {
          errPen magenta writeln: 'route handler for ${{route}}$ existed at ${{f path}}$ and was modified since creation time, not touching it', resetColor.
          exists is True.
        } ifFalse: {
          errPen green write: 'route handler for ${{route}}$ existed at ${{f path}}$,', red writeln: ' overwriting it', resetColor.
        }.
      }.
      exists ifFalse: {
        f open: 'w+'.
        f write: 'const {%:L} = require("../types.js");\n\n' % [', ', typenames].
        f write: 'const {%:L} = require("../models.js");\n\n' % [', ', modelnames].
        f write: typedoc_out + '\n' + typedoc_in + '\n' + out_constructors +
                 '\n\nmodule.exports = async function process_${{route ~ 's/\\W/_/g'}}$(res_input, res_output)' +
                 ' {\n\t// TODO: implement\n\treturn res_output;\n}'.
        f close.
        timestamps put: f stat @ 'st_ctime' at: f path.
      }.
      var decoder is 'JSON.parse'.
      var buffer is '""'.
      var bufcat is \:buf:new '${{buf}}$ += ${{new}}$.toString()'.
      var bufprocess is \:buf buf.
      spec request isNil ifFalse: {
        decoder is spec request decoder!.
        var dec is decoder split: '.' max: 1, head.
        dec !=: 'JSON', ifTrue: {
          buffer is '[]'.
          bufcat is \:buf:new '${{buf}}$ = [...${{buf}}$, ${{new}}$]'.
          bufprocess is \:buf 'Buffer.concat(${{buf}}$)'.
        }.
      }.
      spec mode = 'post' ifTrue: {
        outPen writeln: 'app.post("/${{route}}$", async (req, res) => {'.
      } ifFalse: {
        outPen writeln: 'app.get("/${{route}}$", async (req, res) => {'.
      }.
      api log = \debug ifTrue: {
        outPen writeln: '\tconsole.log("[DEBUG] activity on route ${{route}}$");'.
      }.
      spec mode = 'post' ifTrue: {
        outPen writeln: '\tvar bodyStr = ${{buffer}}$;'.
        outPen writeln: '\treq.on("data", function(chunk) { '.
        outPen writeln: '\t\t${{bufcat applyTo: 'bodyStr' and: 'chunk'}}$;'.
        outPen writeln: '\t});'.
        outPen writeln: '\treq.on("end", async function() {'.
        outPen writeln: '\t\tbodyStr = ${{bufprocess applyTo: 'bodyStr'}}$'.
        outPen writeln: '\t\tlet ok = false, handled = false, res_input = null, res_output = null;'.
        outPen writeln: '\t\tlet jsondec = ${{decoder}}$(bodyStr);'.
      }.
      var fieldsFL is Array new.
      # get the fields
      (spec request isNil either: True or: { ^spec request fields isNil. }) ifTrue: {
        outPen writeln: '\t\ttry {'.
        outPen writeln: '\t\t\tres_input = {};'.
      } ifFalse: {
        outPen writeln: '\t\ttry {'.
        var fields is spec request fields.
        fields isA: Type, ifTrue: {
          outPen writeln: '\t\t\tres_input = ${{fields _underlayingJSType or: fields}}$;'.
        } ifFalse: {
          outPen writeln: '\t\t\tres_input = {'.
          fields each: {:k:v
            fieldsFL push: [k toString, v ftype].
            fieldsFL push: k toString.
            spec mode = 'get' ifTrue: {
              outPen writeln: '\t\t\t\t\'${{k}}$\': getOrFail(${{v ftype _underlayingJSType or: v ftype}}$, req.query, \'${{k}}$\', ${{v jsdefault}}$),'.
            } ifFalse: {
              outPen writeln: '\t\t\t\t\'${{k}}$\': getOrFail(${{v ftype _underlayingJSType or: v ftype}}$, jsondec, \'${{k}}$\', ${{v jsdefault}}$),'.
            }.
          }.
          outPen writeln: '\t\t\t};\n'.
        }.
      }.

      spec before isNil ifFalse: {
        outPen writeln: '\t\t\tlet failure = {error:null, ok:null};'.
        spec before each: {:func:fn
          fn returns ifTrue: {
            outPen writeln: '\t\t\tlet ${{fn}}$_${{fn return fname}}$ = {set value(val) { res_input["${{fn return fname}}$"] = val; }};'.
          }.
        }.
        outPen write: '\t\t\tif (!('.
        spec before each: {:func:fn
          outPen write: 'await ${{fn}}$('.
          var s is Array new.
          function getStructure: fn structureId, each: {:v:k
            fieldsFL contains: [v toString, k ftype], ifFalse: {
              errPen yellow write: '(Route ${{route}}$) parameter $$v of function $$fn does not seem to exist'.
              fieldsFL contains: v toString, ifTrue: {
                var type is fieldsFL filter_v: {:x ^x isA: Array, either: { ^x head = v. } or: False.}.
                type count = 0 ifTrue: {
                  errPen write: ', while being registered ', red write: '(Internal Compiler Error)'.
                } ifFalse: {
                  type is type head last.
                  errPen write: ' with the valid type (expected ${{k ftype}}$, but found ${{type}}$)'.
                }.
              }.
              errPen resetColor brk.
            }.
            s push: '"${{v}}$": res_input["${{v}}$"]'.
          }.
          s is Array < ('{' + (s join: ', ') + '}').
          s push: 'failure'.
          fn returns ifTrue: {
            var ret is fn return.
            fieldsFL push: [ret fname, ret ftype].
            fieldsFL push: ret fname.
            s push: '${{fn}}$_${{ret fname}}$'.
          }.
          outPen write: '%:L' % [', ', s].
          outPen write: ') &&\n\t\t\t    '.
        }.
        outPen writeln: 'true)) {'.
        outPen writeln: '\t\t\t\thandled = true;\n\t\t\t\tres.status(500).send(failure);'.
        outPen writeln: '\t\t\t\treturn;'.
        outPen writeln: '\t\t\t}'.
      }.

      # generate the output structure
      (spec response isNil either: True or: { ^spec response fields isNil. }) ifTrue: {
        outPen writeln: '\t\t\tres_output = {'.
        outPen writeln: '\t\t\t};'.
      } ifFalse: {
        var fields is spec response fields.
        fields isA: Type, ifTrue: {
          outPen writeln: '\t\t\tres_output = {} /* ${{fields _underlayingJSType or: fields}}$ */;'.
        } ifFalse: {
          outPen writeln: '\t\t\tres_output = {'.
          fields each: {:k:v
            outPen writeln: '\t\t\t\t\'${{k}}$\': null /* ${{v ftype _underlayingJSType or: v ftype}}$ */,'.
          }.
          outPen writeln: '\t\t\t};\n'.
        }.
      }.
      outPen writeln: '\t\t\tres.send(await process_${{route ~ 's/\\W/_/g'}}$(res_input, res_output));\n\t\t\tok = true;\n'.
      outPen writeln: '\t\t} catch(e) {\n\t\t\tok = false;\n\t\t\thandled = true;\n\t\t\tres.status(500).send({_error: e.toString(), ...res_output});'.
      outPen writeln: '\t\t} finally {\n\t\t\tif (!ok && !handled) res.status(500).send(res_output);\n\t\t\t}'.
      outPen writeln: '\n});'.
      spec mode = 'post' ifTrue: {
        outPen writeln: '\t});'.
      }.
    }.
    # then, define the routes and processors for actions
    { File new: 'actions', mkdir. } catch: {}, run.
    actions each: {:route:spec
      var typedoc_in is '/**\n * res_input\n'.
      var typedoc_out is '/**\n * res_output\n'.
      var out_constructors is ''.

      (spec request isNil either: True or: { ^spec request fields isNil. }) ifTrue: {
        typedoc_in +=: ' */\n'.
      } ifFalse: {
        var fields is spec request fields.
        fields isA: Type, ifTrue: {
          typedoc_in +=: ' * = ${{fields _underlayingJSType or: fields}}$\n'.
        } ifFalse: {
          spec request fields each: {:k:v
            typedoc_in +=: ' * @param ${{k}}$: ${{v ftype _underlayingJSType or: v ftype}}$\n'.
          }.
        }.
        typedoc_in +=: ' */\n'.
      }.

      (spec response isNil either: True or: { ^spec response fields isNil. }) ifTrue: {
        typedoc_out +=: ' */\n'.
      } ifFalse: {
        var fields is spec response fields.
        fields isA: Type, ifTrue: {
          typedoc_out +=: ' * = ${{fields _underlayingJSType or: fields}}$\n'.
        } ifFalse: {
          spec response fields each: {:k:v
            typedoc_out +=: ' * @param ${{k}}$: ${{v ftype _underlayingJSType or: v ftype}}$\n'.
            out_constructors +=: 'construct${{k upper1st}}$ = x => (${{v ftype _underlayingJSType or: v ftype}}$).call(null, x);\n'.
          }.
        }.
        typedoc_out +=: ' */\n'.
      }.

      var f is File new: 'endpoints/${{route ~ 's/\\W/_/g'}}$.js'.
      var exists is False.
      f exists ifTrue: {
        timestamps @ f path < (f stat @ 'st_mtime') ifTrue: {
          errPen magenta writeln: 'route handler for ${{route}}$ existed at ${{f path}}$ and was modified since creation time, not touching it', resetColor.
          exists is True.
        } ifFalse: {
          errPen green write: 'route handler for ${{route}}$ existed at ${{f path}}$,', red writeln: ' overwriting it', resetColor.
        }.
      }.
      exists ifFalse: {
        f open: 'w+'.
        f write: 'const {%:L} = require("../types.js");\n\n' % [', ', typenames].
        f write: 'const {%:L} = require("../models.js");\n\n' % [', ', modelnames].
        f write: typedoc_out + '\n' + typedoc_in +
                 'module.exports = async function process_${{route ~ 's/\\W/_/g'}}$(res_input, res_output)' +
                 ' {\n\t// TODO: implement\n\treturn res_output;\n}'.
        f close.
        timestamps put: f stat @ 'st_ctime' at: f path.
      }.
      spec action each: {:idx:action
        var f is File new: 'actions/${{route ~ 's/\\W/_/g'}}$-action${{idx}}$.js'.
        f exists ifTrue: {
          errPen magenta writeln: 'action #$$idx for route ${{route}}$ existed at ${{f path}}$, not touching it', resetColor.
        } ifFalse: {
          f open: 'w+'.
          f write: 'const {%:L} = require("../types.js");\n\n' % [', ', typenames].
          f write: 'const {%:L} = require("../models.js");\n\n' % [', ', modelnames].
          f write: '/**\n * ${{action replace: '\n' with: '\n * '}}$\n */\n' + typedoc_out + '\n' + typedoc_in + '\n' + out_constructors +
                        'module.exports = async function action_${{route ~ 's/\\W/_/g'}}$_${{idx}}$(res, req, res_output, res_input) ' +
                        '{\n\tres_output = res_output; // TODO: Edit me' +
                        '\n\treturn true;\n}\n'.
          f close.
        }.
      }.
      spec mode = 'post' ifTrue: {
        outPen writeln: 'app.post("/${{route}}$", async (req, res) => {'.
      } ifFalse: {
        outPen writeln: 'app.get("/${{route}}$", async (req, res) => {'.
      }.
      api log = \debug ifTrue: {
        outPen writeln: '\tconsole.log("[DEBUG] activity on ${{route}}$");'.
      }.
      var decoder is 'JSON.parse'.
      var buffer is '""'.
      var bufcat is \:buf:new '${{buf}}$ += ${{new}}$.toString()'.
      var bufprocess is \:buf buf.
      spec request isNil ifFalse: {
        decoder is spec request decoder!.
        var dec is decoder split: '.' max: 1, head.
        dec !=: 'JSON', ifTrue: {
          buffer is '[]'.
          bufcat is \:buf:new '${{buf}}$ = [...${{buf}}$, ${{new}}$]'.
          bufprocess is \:buf 'Buffer.concat(${{buf}}$)'.
        }.
      }.

      var fieldsFL is Array new.
      # get the fields
      spec mode = 'post' ifTrue: {
        outPen writeln: '\tvar bodyStr = ${{buffer}}$;'.
        outPen writeln: '\treq.on("data", function(chunk) { '.
        outPen writeln: '\t\t${{bufcat applyTo: 'bodyStr' and: 'chunk'}}$;'.
        outPen writeln: '\t});'.
        outPen writeln: '\treq.on("end", async function() {'.
        outPen writeln: '\t\tbodyStr = ${{bufprocess applyTo: 'bodyStr'}}$'.
        outPen writeln: '\t\tlet ok = false, handled = false, res_input = null, res_output = null;'.
        outPen writeln: '\t\tlet jsondec = ${{decoder}}$(bodyStr);'.
      }.
      (spec request isNil either: True or: { ^spec request fields isNil. }) ifTrue: {
        outPen writeln: '\t\tlet res_input = {};'.
      } ifFalse: {
        spec mode = 'post' ifTrue: {
          outPen writeln: '\t\t\tdbsession.startTransaction();'.
        }.
        outPen writeln: '\t\tlet total_failure = {fail_early: false, action_handled_response: false};'.
        outPen writeln: '\t\ttry {'.
        var fields is spec request fields.
        fields isA: Type, ifTrue: {
          outPen writeln: '\t\t\tres_input = ${{fields _underlayingJSType or: fields}}$.call(_, jsondec);'.
        } ifFalse: {
          outPen writeln: '\t\t\tres_input = {'.
          spec request fields each: {:k:v
            fieldsFL push: [k toString, v ftype].
            fieldsFL push: k toString.
            spec mode = 'get' ifTrue: {
              outPen writeln: '\t\t\t\t\'${{k}}$\': getOrFail(${{v ftype _underlayingJSType or: v ftype}}$, req.query, \'${{k}}$\', ${{v jsdefault}}$),'.
            } ifFalse: {
              outPen writeln: '\t\t\t\t\'${{k}}$\': getOrFail(${{v ftype _underlayingJSType or: v ftype}}$, jsondec, \'${{k}}$\', ${{v jsdefault}}$),'.
            }.
          }.
          outPen writeln: '\t\t\t};\n'.
        }.
      }.
      spec before isNil ifFalse: {
        outPen writeln: '\t\t\tlet failure = {error:null, ok:null};'.
        spec before each: {:func:fn
          fn returns ifTrue: {
            var ret is fn return.
            fieldsFL push: [ret fname, ret ftype].
            fieldsFL push: ret fname.
            outPen writeln: '\t\t\tlet ${{fn}}$_${{fn return fname}}$ = {set value(val) { res_input["${{fn return fname}}$"] = val; }};'.
          }.
        }.
        outPen write: '\t\t\tif (!('.
        spec before each: {:func:fn
          outPen write: 'await ${{fn}}$('.
          var s is Array new.
          function getStructure: fn structureId, each: {:v:k
            fieldsFL contains: [v toString, k ftype], ifFalse: {
              errPen yellow write: '(Route ${{route}}$) parameter $$v of function $$fn does not seem to exist'.
              fieldsFL contains: v toString, ifTrue: {
                var type is fieldsFL filter_v: {:x ^x isA: Array, either: { ^x head = v. } or: False.}.
                type count = 0 ifTrue: {
                  errPen write: ', while being registered ', red write: '(Internal Compiler Error)'.
                } ifFalse: {
                  type is type head last.
                  errPen write: ' with the valid type (expected ${{k ftype}}$, but found ${{type}}$)'.
                }.
              }.
              errPen resetColor brk.
            }.
            s push: '"${{v}}$": res_input["${{v}}$"]'.
          }.
          s is Array < ('{' + (s join: ', ') + '}').
          s push: 'failure'.
          fn returns ifTrue: {
            s push: '${{fn}}$_${{fn return fname}}$'.
          }.
          outPen write: '%:L' % [', ', s].
          outPen write: ') &&\n\t\t\t    '.
        }.
        outPen writeln: 'true)) {'.
        outPen writeln: '\t\t\t\thandled = true;\n\t\t\t\tres.status(500).send(failure);'.
        outPen writeln: '\t\t\t\treturn;'.
        outPen writeln: '\t\t\t}'.
      }.

      # generate the output structure
      (spec response isNil either: True or: { ^spec response fields isNil. }) ifTrue: {
        outPen writeln: '\t\t\tres_output = {};'.
      } ifFalse: {
        var fields is spec response fields.
        fields isA: Type, ifTrue: {
          outPen writeln: '\t\t\tres_output = {} /* ${{fields _underlayingJSType or: fields}}$ */;'.
        } ifFalse: {
          outPen writeln: '\t\t\tres_output = {'.
          spec response fields each: {:k:v
            outPen writeln: '\t\t\t\t\'${{k}}$\': null /* ${{v ftype _underlayingJSType or: v ftype}}$ */,'.
          }.
          outPen writeln: '\t\t\t};\n'.
        }.
      }.
      outPen write: '\t\t\tif ('.
      spec action each: {:idx:action
        outPen write: 'await action_${{route ~ 's/\\W/_/g'}}$_${{idx}}$(res, req, res_output, res_input, total_failure) &&\n\t\t\t    '.
      }.
      outPen writeln: 'true) {'.
      outPen writeln: '\t\t\t\tres.send(await process_${{route ~ 's/\\W/_/g'}}$(res_input, res_output));'.
      outPen writeln: '\t\t\t\tok = true;\n\t\t\t}'.
      outPen writeln: '\t\t\telse {\n\t\t\t\tok = false;\n\t\t\t}'.
      outPen writeln: '\t\t\thandled = total_failure.action_handled_response;'.
      outPen writeln: '\t\t} catch(e) {\n\t\t\tok = false;\n\t\t\thandled = true;\n\t\t\tres.status(500).send({_error: e.toString(), ...res_output});'.
      outPen writeln: '\t\t} finally {'.
      spec mode = 'post' ifTrue: {
        outPen writeln: '\t\t\tif (ok && !total_failure.fail_early)\n\t\t\t\tawait dbsession.commitTransaction();\n\t\t\telse await dbsession.abortTransaction();'.
      }.
      outPen writeln: '\t\t\tif (!ok && !handled) res.status(500).send(res_output);\n\t\t\t}'.
      outPen writeln: '\t});'.
      spec mode = 'post' ifTrue: {
        outPen writeln: '\t});'.
      }.
    }.
    outPen writeln: 'MongoClient.connect(config.mongo_addr, {useNewUrlParser: true}, (err, client) => {'.
    outPen writeln: '\tif (err) return console.log(err);'.
    outPen writeln: '\tdbsession = client.startSession();'.
    outPen writeln: '\tdb = client.db(config.database);'.
    outPen writeln: '\tapp.listen(config.port, () => console.log("App listening on port " + config.port));'.
    outPen writeln: '});'.

    # create a config file if it doesn't exist
    var cfg is File new: 'config.js'.
    cfg exists ifFalse: {
      cfg write: 'module.exports = {\n\tport: 8080,\n\tmongo_addr: "mongodb://127.0.0.1",\n\tdatabase: "fancy_db_name"\n};'.
    }.

    # record timestamps
    File new: 'timestamps.ctr', write: 'var data is ' + timestamps + '.'.
  }.
}.

var API is Object cnew: { # api interface
  req => Nil.

  on: 'new' do: {}.
  on: 'cnew:' do: {}.

  on: 'toString' do: {
    ^'API'.
  }.
  on: 'type' do: {
    ^'APIInterface'.
  }.

  on: 'load:' do: {:apiname
    (apiname = my req | my req isNil) ifTrue: {
      var id is const api ignoreRequests.
      import respondTo: apiname.
      const api enableRequests: id.
      req => apiname.
    } ifFalse: {
      thisBlock error: 'api spec ${{my apiname}}$ already loaded'.
    }.
  }.
  on: 'incompletePoints' do: {
    ^const api listIncomplete.
  }.
  on: 'writeJsonFor:' do: {:points
    const api writeJsonFor: points.
  }.
  on: 'displayModel:' do: {:m
    ^const model miniPrintStructureEx: (const model getStructure: (const model allInstanceTypes at: m)).
  }.
}.

var errPen is pPen for: (File special: 'stderr').
var outPen is pPen for: api openOutputFile.
