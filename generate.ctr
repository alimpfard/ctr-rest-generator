import Library/Data/IO/Pen: 'pPen'.

var errPen is pPen for: (File special: 'stderr').
var outPen is pPen for: (File new: 'out.js', open: 'w+').

var type is Object cnew: {
  on: 'new' do: {}.
  # on: 'cnew:' do: {}.

  allInstanceTypes => HashMap new.
  structures => Map new.
  alternative => False.
  on: 'complete' do: {
    alternative => False.
  }.
  on: 'allInstanceTypes' do: { ^my allInstanceTypes. }.
  on: 'respondTo:' do: {:self:typename
    typename = 'alternative' ifTrue: {
      alternative => True.
      ^me.
    }.
    var alternative is my alternative.
    ^Object cnew: {
      name => typename.
      alternative => alternative.
      type => self.
      on: 'applyAll:' do: {:defn
        my alternative ifTrue: {
          errPen yellow write: 'type ${{my name}}$ has alternative definitions, ', resetColor.
          errPen red writeln: 'it will not be recorded (TODO)', resetColor.
        } ifFalse: {
          var structureId is my type getOrCreateStructure: defn.
          my type register: my name as: structureId.
          Reflect addGlobalVariable: my name.
          var type is Type cnew: { structureId => structureId. underlayingJSType => Nil. } named: my name.
          Reflect set: my name to: type.
        }.
        my type complete.
      }.
    }.
  }.
  on: 'register:as:' do: {:name:structureId
    my allInstanceTypes at: name, isNil ifFalse: {
      my alternative ifFalse: {
        errPen red writeln: 'structure $$structureId (${{miniPrintStructure: structureId}}$) already registered', resetColor.
      }.
      ^Nil.
    }.
    my allInstanceTypes put: structureId at: name.
  }.
  on: 'compileStructure:' do: {:str
    var tymap is HashMap new.
    str each_v: {:ntpair
      tymap contains: ntpair fname, ifTrue: {
        errPen red writeln: 'field ${{ntpair fname}}$ already exists in the structure as ${{tymap at: ntpair fname}}$, ignoring the new field', resetColor.
      } ifFalse: {
        tymap put: ntpair ftype at: ntpair fname.
      }.
    }.
    ^tymap.
  }.
  on: 'getOrCreateStructure:' do: {:structure
    var compiled is compileStructure: structure.
    my structures put: compiled at: (var id is my structures count).
    ^id.
  }.
  on: 'getStructure:' do: {:id
    ^my structures at: id.
  }.
  on: 'miniPrintStructure:' do: {:id
    var compiled is my structures at: id.
    compiled isNil ifTrue: {
      ^'{}'.
    }.
    ^miniPrintStructureEx: compiled.
  }.
  on: 'miniPrintStructureEx:' do: {:compiled
    var s is '{'.
    compiled isA: Type, ifTrue: {
      s +=: (compiled _underlayingJSType or: compiled) + ', '.
    } ifFalse: {
      compiled each: {:k:v
        s +=: '${{k}}$:${{v}}$, '.
      }.
    }.
    ^s from: 0 length: s length - 2, + '}'.
  }.
}.

var Type is Object cnew: {
  on: 'cnew:named:' do: {:blk:name
    ^me cnew: blk, name: name.
  }.
  genAccessors: ['structureId'].
  on: 'name:' do: {:name my name is name. }.
  on: 'toString' do: { ^my name. }.
  on: 'applyAll:' do: {
    ^ArrayType getOrCreate: me.
  }.
  on: '_underlayingJSType' do: { ^my underlayingJSType or: my name. }.
  on: 'respondTo:' do: {:self:name
    ^Object cnew: {
      ftype => self.
      fname => name.
      underlayingJSType => Nil.
      default => Nil.
      unique? => False.
      genAccessors: ['fname', 'ftype', 'unique?'].
      on: 'unique' do: { my unique? is True. }.
      on: 'toString' do: {
        ^'<%s %s>' % [my ftype, my fname].
      }.
      on: 'default:' do: {:def default => def. }.
      on: 'default' do: { ^my default or: my ftype _underlayingJSType, or: my ftype. }.
      on: 'type' do: { ^'NameTypePair'. }.
      on: 'applyAll:' do: {:x default: x head. }.
      on: '=' do: {:other
        other type = 'NameTypePair' ifTrue: {
          ^(my fname = other fname) & (my ftype = other ftype).
        } ifFalse: {
          ^False.
        }.
      }.
    }.
  }.
}.

var ArrayType is Type cnew: {
  typemap => Map new.
  on: 'getOrCreate:' do: {:inner
    var instance is my typemap at: inner.
    instance isNil ifTrue: {
      instance is me create: inner.
      my typemap put: instance at: inner.
      ^instance.
    } ifFalse: {
      ^instance.
    }.
  }.
  on: 'create:' do: {:inner
    ^me cnew: {
      etype => inner.
    }.
  }.
  on: '_underlayingJSType' do: { ^'ArrayType(' + (my etype _underlayingJSType or: my etype) + ')'. }.
  on: 'toString' do: {
    ^'%s[]' % [my etype].
  }.
}.

var int is Type cnew: {
  underlayingJSType => 'Number'.
} named: 'int'.

var string is Type cnew: {
  underlayingJSType => 'String'.
} named: 'string'.

var double is Type cnew: {
  underlayingJSType => 'Number'.
} named: 'double'.

var boolean is Type cnew: {
  underlayingJSType => 'Boolean'.
} named: 'boolean'.

var enum is Object cnew: {
  choicemap => Map new.
  on: 'applyAll:' do: {:choices
    var ty is my choicemap at: choices.
    ty isNil ifTrue: {
      ty is Type cnew: {
        choices => choices.
        underlayingJSType => 'String'.
      } named: 'enum' + (my choicemap count).
    }.
    ^ty.
  }.
}.

type register: 'int' as: int.
type register: 'string' as: string.
type register: 'double' as: double.
type register: 'boolean' as: boolean.

###################################  Request ###################################
var Specification is Object cnew: {
  on: 'toString' do: { ^'<Spec: ${{type miniPrintStructureEx: my fields}}$>'. }.
  on: 'fields' do: { ^my fields. }.
}.
var RequestSpecification is Specification cnew: {

}.
var ResponseSpecification is Specification cnew: {

}.
var ActionSpecification is Specification cnew: {
  on: 'toString' do: { ^'<ActionSpec: %L>' % [my comments fmap: \:x '"%s"' % [x]]. }.
  on: 'each:' do: {:blk
    my comments each: blk.
  }.
}.
var Request is Object cnew: {
  on: 'applyAll:' do: {:args
    ^RequestSpecification cnew: {
      fields => (type compileStructure: args).
    }.
  }.
  on: 'respondTo:' do: {:name
    var ty is Reflect getObject: name.
    ^RequestSpecification cnew: {
      fields => ty. #type getStructure: ty structureId, or: (model getStructure: ty structureId).
    }.
  }.
}.
var Response is Object cnew: {
  on: 'applyAll:' do: {:args
    ^ResponseSpecification cnew: {
      fields => (type compileStructure: args).
    }.
  }.

  on: 'respondTo:' do: {:name
    var ty is Reflect getObject: name.
    ^ResponseSpecification cnew: {
      fields => ty. #type getStructure: ty structureId, or: (model getStructure: ty structureId).
    }.
  }.
}.
var Action is Object cnew: {
  on: 'applyAll:' do: {:args
    ^ActionSpecification cnew: {
      comments => args.
    }.
  }.
  on: 'process:' do: {:arg ^me applyAll: [arg]. }.
}.
################################### endpoint ###################################
#################################### action ####################################
var endpoints is Map new.
var actions is Map new.

var EndpointSpec is Object cnew: {
  on: 'create:withRequest:andResponse:' do: {:name:request:response
    ^cnew: {
      request => request.
      response => response.
      name => name.
    }.
  }.
  genAccessors: ['request', 'response'].
  on: 'each:' do: {:blk
    my request isNil ifFalse: {
      blk applyTo: 'Request' and: my request.
    }.
    my response isNil ifFalse: {
      blk applyTo: 'Response' and: my response.
    }.
  }.
  on: 'toString' do: {
    ^'<Endpoint "%s" req: %s, resp: %s>' % [my name, my request, my response].
  }.
}.

var ActionSpec is Object cnew: {
  on: 'create:withRequest:andResponse:andAction:' do: {:name:request:response:action
    ^cnew: {
      request => request.
      response => response.
      action => action.
      name => name.
    }.
  }.
  genAccessors: ['request', 'response', 'action'].
  on: 'each:' do: {:blk
    my request isNil ifFalse: {
      blk applyTo: 'Request' and: my request.
    }.
    my response isNil ifFalse: {
      blk applyTo: 'Response' and: my response.
    }.
    my action isNil ifFalse: {
      blk applyTo: 'Action' and: my action.
    }.
  }.
  on: 'toString' do: {
    ^'<Action "%s" req: %s, resp: %s, act: %s>' % [my name, my request, my response, my action].
  }.
}.

var endpoint is Object cnew: {
  on: 'respondTo:' do: {:name
    endpoints contains: name, ifTrue: {
      outPen red writeln: 'an endpoint named \'${{name}}$\' has already been registered'.
      ^Nil.
    }.
    ^Object cnew: {
      name => name.
      endpoints => endpoints.
      on: 'applyAll:' do: {:args
        var req is Nil.
        var res is Nil.
        args each_v: {:arg
          arg isA: RequestSpecification, ifTrue: {
            req is arg.
            ^Nil.
          }.
          arg isA: ResponseSpecification, ifTrue: {
            res is arg.
            ^Nil.
          }.
          errPen red writeln: 'endpoint specification can only be a Request or a Response', resetColor.
        }.
        my endpoints put: (
          EndpointSpec
            create: my name
            withRequest: req
            andResponse: res)
          at: my name.
      }.
    }.
  }.
}.
var action is Object cnew: {
  on: 'respondTo:' do: {:name
    actions contains: name, ifTrue: {
      errPen red writeln: 'an action named \'${{name}}$\' has already been registered'.
      ^Nil.
    }.
    ^Object cnew: {
      name => name.
      actions => actions.
      on: 'applyAll:' do: {:args
        var req is Nil.
        var res is Nil.
        var act is Nil.
        args each_v: {:arg
          arg isA: RequestSpecification, ifTrue: {
            req is arg.
            ^Nil.
          }.
          arg isA: ResponseSpecification, ifTrue: {
            res is arg.
            ^Nil.
          }.
          arg isA: ActionSpecification, ifTrue: {
            act is arg.
            ^Nil.
          }.
          errPen red writeln: 'action specification can only be a Request, a Response or an Action', resetColor.
        }.
        act isNil ifTrue: {
          errPen red writeln: 'action rule ${{my name}}$ contains no `Action` field', resetColor.
        }.
        my actions put: (
          ActionSpec
            create: my name
            withRequest: req
            andResponse: res
            andAction: act
        ) at: my name.
      }.
    }.
  }.
}.

#################################### model #####################################
var models is Map new.

var ModelSpec is Object cnew: {
  # TODO
}.

var model is type cnew: {
  allInstanceTypes => HashMap new.
  structures => Map new.
  alternative => False.
}.

var reference is Type cnew: {
  on: 'applyAll:' do: {:ex
    ^ReferenceType getOrCreate: ex head.
  }.
} named: 'reference'.

var ReferenceType is Type cnew: {
  typemap => Map new.
  on: 'getOrCreate:' do: {:inner
    var instance is my typemap at: inner.
    instance isNil ifTrue: {
      instance is me create: inner.
      my typemap put: instance at: inner.
      ^instance.
    } ifFalse: {
      ^instance.
    }.
  }.
  on: 'create:' do: {:inner
    ^me cnew: {
      etype => inner.
    }.
  }.
  on: '_underlayingJSType' do: { ^'Number'. }.
  on: 'toString' do: {
    ^'reference[%s]' % [my etype].
  }.
}.

model register: 'int' as: int.
model register: 'string' as: string.
model register: 'double' as: double.
model register: 'boolean' as: boolean.
model register: 'reference' as: reference.

################################ generate api ##################################

var api is Object cnew: {
  loglevel => \none. # debug, info, warn, none
  endpointType => 'get'.
  on: 'postEndpoints' do: { endpointType => 'post'. }.
  on: 'getEndpoints' do: { endpointType => 'get'. }.
  on: 'endpointType' do: { ^my endpointType. }.
  on: 'log:' do: {:level
    loglevel => level.
  }.
  on: 'log' do: { ^my loglevel. }.
  on: 'prettyPrintSpec:' do: {:spec
    var s is ''.
    spec each: {:ty:spc
      s +=: '$$ty [\n\t\t\t\t$$spc'.
      s +=: '\n\t\t\t],\n\t\t\t'.
    }.
    ^s.
  }.
  on: 'toString' do: {
    ^'Actions:\n' + actions + '\n' + ('-' * 80) + '\n' + 'Endpoints:\n' + endpoints + '\n'.
  }.
  on: 'describe' do: {
    outPen writeln: 'These types are defined:'.
    type allInstanceTypes each: {:k:v
      outPen writeln: '\t$$k - $$v ${{type miniPrintStructure: v}}$'.
    }.
    model allInstanceTypes each: {:k:v
      outPen writeln: '\t$$k - $$v ${{model miniPrintStructure: v}}$'.
    }.
    outPen write: 'The API has ${{actions count}}$ Actions'.
    outPen writeln: ', and ${{endpoints count}}$ Endpoints:'.
    actions each: {:name:spec
      outPen writeln: '\taction $$name ['.
      outPen writeln: '\t\t${{prettyPrintSpec: spec}}$'.
      outPen writeln: '\t]'.
    }.
    endpoints each: {:name:spec
      outPen writeln: '\tendpoint $$name ['.
      outPen writeln: '\t\t${{prettyPrintSpec: spec}}$'.
      outPen writeln: '\t]'.
    }.
  }.
  on: 'generate' do: {
    # generate js...?
    # express + toplevel boilerplate
    outPen writeln: 'var express = require("express");\nvar app = express();\n'.
    outPen writeln: 'db = null; const config = require("./config.js");\nconst MongoClient = require("mongodb").MongoClient;\n'.
    endpoints each: {:k
      outPen writeln: 'const process_${{k ~ 's/\\W/_/g'}}$ = require("./endpoints/${{k ~ 's/\\W/_/g'}}$.js");'.
    }.
    actions each: {:k:spec
      outPen writeln: 'const process_${{k ~ 's/\\W/_/g'}}$ = require("./endpoints/${{k ~ 's/\\W/_/g'}}$.js");'.
      spec action each: {:i
        outPen writeln: 'const action_${{k ~ 's/\\W/_/g'}}$_${{i}}$ = require("./actions/${{k ~ 's/\\W/_/g'}}$-action${{i}}$.js");'.
      }.
    }.
    outPen brk.
    # first, define the types
    var f is File new: 'types.js'.
    f exists ifTrue: {
      errPen magenta write: 'types file exists at $$f', red write: ' overwriting it.', resetColor brk.
    }.
    f open: 'w+'.
    var typePen is pPen for: f.
    typePen writeln: 'module.exports = {};'.
    var typenames is Array < 'ArrayType'.
    type allInstanceTypes each: {:k:v
      v isA: Number, ifTrue: {
        typenames push: k.
        typePen writeln: 'let $$k = {'.
        var struct is type getStructure: v.
        struct each: {:k:v
          typePen writeln: '\t\'${{k}}$\': arg => ${{v _underlayingJSType or: v}}$.call(null, arg),'.
        }.
        typePen writeln: '\tcall(_, value) {'.
        typePen writeln: '\t\tlet obj = {};'.
        typePen writeln: '\t\tfor (property in ${{k}}$)'.
        typePen writeln: '\t\t\tif (property !== "call" && ${{k}}$.hasOwnProperty(property))'.
        typePen writeln: '\t\t\t\tobj[property] = ${{k}}$[property](value[property]);'.
        typePen writeln: '\t\treturn obj;\n\t}'.
        typePen writeln: '};'.
        typePen writeln: 'module.exports["${{k}}$"] = $$k'.
        typePen brk.
      }.
    }.
    typePen writeln: 'function ArrayType(inner) {'.
    typePen writeln: '\treturn {\n\t\tcall(_, value) {'.
    typePen writeln: '\t\t\treturn Array.prototype.slice.call(value).map(x => inner.call(null, x));'.
    typePen writeln: '\t\t}\n\t};\n};'.
    typePen writeln: 'module.exports["ArrayType"] = ArrayType;'.
    # then, define the model types
    var modelnames is Array new.
    var f is File new: 'models.js'.
    f exists ifTrue: {
      errPen magenta write: 'models file exists at $$f', red write: ' overwriting it.', resetColor brk.
    }.
    f open: 'w+'.
    var modelPen is pPen for: f.
    modelPen writeln: 'module.exports = {};'.
    var typenames is Array < 'ArrayType'.
    model allInstanceTypes each: {:k:v
      v isA: Number, ifTrue: {
        modelnames push: k.
        modelPen writeln: 'let $$k = {'.
        var struct is model getStructure: v.
        struct each: {:k:v
          modelPen writeln: '\t\'${{k}}$\': arg => ${{v _underlayingJSType or: v}}$.call(null, arg),'.
        }.
        modelPen writeln: '\tcall(_, value) {'.
        modelPen writeln: '\t\tlet obj = {};'.
        modelPen writeln: '\t\tfor (property in ${{k}}$)'.
        modelPen writeln: '\t\t\tif (property !== "call" && property !== "db" && ${{k}}$.hasOwnProperty(property))'.
        modelPen writeln: '\t\t\t\tobj[property] = ${{k}}$[property](value[property]);'.
        modelPen writeln: '\t\treturn obj;\n\t},'.
        # database access methods
        modelPen writeln: '\tdb() { return db.collection("${{k}}$") },'.
        modelPen writeln: '};'.
        modelPen writeln: 'module.exports["${{k}}$"] = $$k'.
        modelPen brk.
      }.
    }.
    # then import all
    outPen writeln: 'const {%:L} = require("./types.js");' % [', ', typenames].
    outPen writeln: 'const {%:L} = require("./models.js");' % [', ', modelnames].
    outPen brk.
    outPen writeln: 'function getOrFail(obj, prop) {\n\t' +
                 'let oprop = obj[prop];\n\t' +
                 'if (oprop !== null) return oprop;\n\t' +
                 'throw new Error(`missing argument ${prop}`);\n}'.
    # then, define the fancy routes for endpoints
    { File new: 'endpoints', mkdir. } catch: {}, run.
    endpoints each: {:route:spec
      var typedoc_in is '/**\n * res_input\n'.
      var typedoc_out is '/**\n * res_output\n'.
      var out_constructors is ''.

      (spec request isNil either: True or: { ^spec request fields isNil. }) ifTrue: {
        typedoc_in +=: ' */\n'.
      } ifFalse: {
        var fields is spec request fields.
        fields isA: Type, ifTrue: {
          typedoc_in +=: ' * @param ${{k}}$: ${{fields _underlayingJSType or: fields}}$\n'.
        } ifFalse: {
          spec request fields each: {:k:v
            typedoc_in +=: ' * @param ${{k}}$: ${{v _underlayingJSType or: v}}$\n'.
          }.
        }.
        typedoc_in +=: ' */\n'.
      }.

      (spec response isNil either: True or: { ^spec response fields isNil. }) ifTrue: {
        typedoc_out +=: ' */\n'.
      } ifFalse: {
        var fields is spec response fields.

        fields isA: Type, ifTrue: {
            typedoc_out +=: ' * = ${{fields _underlayingJSType or: fields}}$\n'.
            out_constructors +=: 'constructReturn = x => (${{fields _underlayingJSType or: fields}}$).call(null, x);\n'.
        } ifFalse: {
          fields each: {:k:v
            typedoc_out +=: ' * @param ${{k}}$: ${{v _underlayingJSType or: v}}$\n'.
            out_constructors +=: 'construct${{k upper1st}}$ = x => (${{v _underlayingJSType or: v}}$).call(null, x);\n'.
          }.
        }.
        typedoc_out +=: ' */\n'.
      }.

      var f is File new: 'endpoints/${{route ~ 's/\\W/_/g'}}$.js'.
      f exists ifTrue: {
        errPen magenta writeln: 'route handler for ${{route}}$ existed at ${{f path}}$, not touching it', resetColor.
      } ifFalse: {
        f open: 'w+'.
        f write: 'const {%:L} = require("../types.js");\n\n' % [', ', typenames].
        f write: 'const {%:L} = require("../models.js");\n\n' % [', ', modelnames].
        f write: typedoc_out + '\n' + typedoc_in + '\n' + out_constructors +
                 '\n\nmodule.exports = async function process_${{route ~ 's/\\W/_/g'}}$(res_input, res_output)' +
                 ' {\n\t// TODO: implement\n\treturn res_output;\n}'.
        f close.
      }.
      outPen writeln: 'app.${{api endpointType}}$("/${{route}}$", async (req, res) => {'.
      api log = \debug ifTrue: {
        outPen writeln: '\tconsole.log("[DEBUG] activity on route ${{route}}$");'.
      }.
      # get the fields
      (spec request isNil either: True or: { ^spec request fields isNil. }) ifTrue: {
        # outPen writeln: '\t\ttry {'.
        outPen writeln: '\t\t\tlet res_input = {};'.
      } ifFalse: {
        # outPen writeln: '\t\ttry {'.
        var fields is spec request fields.
        fields isA: Type, ifTrue: {
          outPen writeln: '\t\t\tlet res_input = ${{fields _underlayingJSType or: fields}}$;'.
        } ifFalse: {
          outPen writeln: '\t\t\tlet res_input = {'.
          fields each: {:k:v
            outPen writeln: '\t\t\t\t\'${{k}}$\': getOrFail(req.params, \'${{k}}$\'),'.
          }.
          outPen writeln: '\t\t\t};\n'.
        }.
      }.

      # generate the output structure
      (spec response isNil either: True or: { ^spec response fields isNil. }) ifTrue: {
        outPen writeln: '\t\t\tlet res_output = {'.
        outPen writeln: '\t\t\t};'.
      } ifFalse: {
        var fields is spec response fields.
        fields isA: Type, ifTrue: {
          outPen writeln: '\t\t\tlet res_output = ${{fields _underlayingJSType or: fields}}$;'.
        } ifFalse: {
          outPen writeln: '\t\t\tlet res_output = {'.
          fields each: {:k:v
            outPen writeln: '\t\t\t\t\'${{k}}$\': ${{v _underlayingJSType or: v}}$,'.
          }.
          outPen writeln: '\t\t\t};\n'.
        }.
      }.
      outPen writeln: '\t\t\tres.send(await process_${{route ~ 's/\\W/_/g'}}$(res_input, res_output));\n'.
      # outPen writeln: '\t\t} catch(e) { res.status(500).send({error: e.toString()}); }'.
      outPen writeln: '\n});'.
    }.
    # then, define the routes and processors for actions
    { File new: 'actions', mkdir. } catch: {}, run.
    actions each: {:route:spec
      var typedoc_in is '/**\n * res_input\n'.
      var typedoc_out is '/**\n * res_output\n'.
      var out_constructors is ''.

      (spec request isNil either: True or: { ^spec request fields isNil. }) ifTrue: {
        typedoc_in +=: ' */\n'.
      } ifFalse: {
        var fields is spec request fields.
        fields isA: Type, ifTrue: {
          typedoc_in +=: ' * = ${{fields _underlayingJSType or: fields}}$\n'.
        } ifFalse: {
          spec request fields each: {:k:v
            typedoc_in +=: ' * @param ${{k}}$: ${{v _underlayingJSType or: v}}$\n'.
          }.
        }.
        typedoc_in +=: ' */\n'.
      }.

      (spec response isNil either: True or: { ^spec response fields isNil. }) ifTrue: {
        typedoc_out +=: ' */\n'.
      } ifFalse: {
        var fields is spec response fields.
        fields isA: Type, ifTrue: {
          typedoc_out +=: ' * = ${{fields _underlayingJSType or: fields}}$\n'.
        } ifFalse: {
          spec response fields each: {:k:v
            typedoc_out +=: ' * @param ${{k}}$: ${{v _underlayingJSType or: v}}$\n'.
            out_constructors +=: 'construct${{k upper1st}}$ = x => (${{v _underlayingJSType or: v}}$).call(null, x);\n'.
          }.
        }.
        typedoc_out +=: ' */\n'.
      }.

      var f is File new: 'endpoints/${{route ~ 's/\\W/_/g'}}$.js'.
      f exists ifTrue: {
        errPen magenta writeln: 'route handler for ${{route}}$ existed at ${{f path}}$, not touching it', resetColor.
      } ifFalse: {
        f open: 'w+'.
        f write: 'const {%:L} = require("../types.js");\n\n' % [', ', typenames].
        f write: 'const {%:L} = require("../models.js");\n\n' % [', ', modelnames].
        f write: typedoc_out + '\n' + typedoc_in +
                 'module.exports = async function process_${{route ~ 's/\\W/_/g'}}$(res_input, res_output)' +
                 ' {\n\t// TODO: implement\n\treturn res_output;\n}'.
        f close.
      }.
      spec action each: {:idx:action
        var f is File new: 'actions/${{route ~ 's/\\W/_/g'}}$-action${{idx}}$.js'.
        f exists ifTrue: {
          errPen magenta writeln: 'action #$$idx for route ${{route}}$ existed at ${{f path}}$, not touching it', resetColor.
        } ifFalse: {
          f open: 'w+'.
          f write: 'const {%:L} = require("../types.js");\n\n' % [', ', typenames].
          f write: 'const {%:L} = require("../models.js");\n\n' % [', ', modelnames].
          f write: '/**\n * ${{action replace: '\n' with: '\n * '}}$\n */\n' + typedoc_out + '\n' + typedoc_in + '\n' + out_constructors +
                        'async function action_${{route ~ 's/\\W/_/g'}}$_${{idx}}$(res, req, res_output, res_input) ' +
                        '{\n\tres_output = res_output; // TODO: Edit me' +
                        '\n\treturn true;\n}\n'.
          f close.
        }.
      }.
      outPen writeln: 'app.post("/${{route}}$", async (req, res) => {'.
      api log = \debug ifTrue: {
        outPen writeln: '\tconsole.log("[DEBUG] activity on ${{route}}$");'.
      }.
      # get the fields
      outPen writeln: '\tvar bodyStr = "";'.
      outPen writeln: '\treq.on("data", function(chunk) { '.
      outPen writeln: '\t\tbodyStr += chunk.toString();'.
      outPen writeln: '\t});'.
      outPen writeln: '\treq.on("end", async function() {'.
      (spec request isNil either: True or: { ^spec request fields isNil. }) ifTrue: {
        outPen writeln: '\t\tlet res_input = {};'.
      } ifFalse: {
        outPen writeln: '\t\ttry {'.
        outPen writeln: '\t\t\tlet jsondec = JSON.parse(bodyStr);'.
        var fields is spec request fields.
        fields isA: Type, ifTrue: {
          outPen writeln: '\t\t\tlet res_input = ${{fields _underlayingJSType or: fields}}$.call(_, jsondec);'.
        } ifFalse: {
          outPen writeln: '\t\t\tlet res_input = {'.
          spec request fields each: {:k:v
            outPen writeln: '\t\t\t\t\'${{k}}$\': getOrFail(jsondec, \'${{k}}$\'),'.
          }.
          outPen writeln: '\t\t\t};\n'.
        }.
      }.

      # generate the output structure
      (spec response isNil either: True or: { ^spec response fields isNil. }) ifTrue: {
        outPen writeln: '\t\t\tlet res_output = {};'.
      } ifFalse: {
        var fields is spec response fields.
        fields isA: Type, ifTrue: {
          outPen writeln: '\t\t\tlet res_output = ${{fields _underlayingJSType or: v}}$;'.
        } ifFalse: {
          outPen writeln: '\t\t\tlet res_output = {'.
          spec response fields each: {:k:v
            outPen writeln: '\t\t\t\t\'${{k}}$\': ${{v _underlayingJSType or: v}}$,'.
          }.
          outPen writeln: '\t\t\t};\n'.
        }.
      }.
      var last_idx is 0.
      spec action each: {:idx:action
        outPen writeln: ('\t' * idx) + '\t\t\tif (await action_${{route ~ 's/\\W/_/g'}}$_${{idx}}$(res, req, res_output, res_input))'.
        last_idx is idx.
      }.
      outPen writeln: ('\t' * (last_idx + 1)) + '\t\t\tres.send(await process_${{route ~ 's/\\W/_/g'}}$(res_input, res_output));\n'.
      outPen writeln: '\t\t} catch(e) { res.status(500).send({error: e.toString()}); }'.
      outPen writeln: '\t});\n});'.
    }.
    outPen writeln: 'MongoClient.connect(config.mongo_addr, {useNewUrlParser: true}, (err, client) => {'.
    outPen writeln: '\tif (err) return console.log(err);'.
    outPen writeln: '\tdb = client.db(config.database);'.
    outPen writeln: '\tapp.listen(config.port, () => console.log("App listening on port " + config.port));'.
    outPen writeln: '});'.

    # create a config file if it doesn't exist
    var cfg is File new: 'config.js'.
    cfg exists ifFalse: {
      cfg write: 'module.exports = {\n\tport: 8080,\n\tmongo_addr: "mongodb://127.0.0.1",\n\tdatabase: "fancy_db_name"\n};'.
    }.
  }.
}.
